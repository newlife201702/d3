<!DOCTYPE html>
<html>
<head>
    <style>
        /* 全屏样式 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .control-btn {
            position: fixed;
            top: 10px;
            z-index: 1000;
            padding: 8px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #fullscreen-btn {
            right: 10px;
        }

        #export-btn {
            right: 100px;
        }

        .node ellipse {
            stroke: #333;
            stroke-width: 1.5px;
            fill: white; /* 所有节点背景设为白色 */
        }

        .node text {
            font-weight: bold;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            fill: #333; /* 文字颜色设为深色 */
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.8;
            stroke-width: 1.5px;
        }

        .arrow {
            fill: #999;
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="export-btn" class="control-btn">导出图片</button>
        <button id="fullscreen-btn" class="control-btn">全屏切换</button>
        <svg id="main-svg"></svg>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvg/dist/browser/canvg.min.js"></script>
    <script>
        // 初始化变量
        let width, height;
        let simulation;
        let zoom;
        const minNodeSize = 20;
        const maxNodeSize = 60;

        // 按钮事件监听
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
        document.getElementById('export-btn').addEventListener('click', exportHighQualityPNG);

        // 初始化可视化
        initVisualization();

        async function initVisualization() {
            // 加载数据
            const data = await d3.csv('links.csv');
            
            // 首次渲染
            updateDimensions();
            setupSVG();
            processData(data);
            createSimulation();
            renderElements();

            // 窗口尺寸变化监听
            window.addEventListener('resize', handleResize);
        }

        function updateDimensions() {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        function setupSVG() {
            const svg = d3.select('#main-svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height]);

            // 添加箭头标记定义
            svg.append('defs').selectAll('marker')
                .data(['arrow'])
                .enter().append('marker')
                .attr('id', d => d)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 25)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('class', 'arrow')
                .attr('d', 'M0,-5L10,0L0,5');
        }

        function processData(data) {
            // 节点处理
            const nodes = {};
            data.forEach(d => {
                nodes[d.source] = nodes[d.source] || { 
                    id: d.source, 
                    links: 0
                };
                nodes[d.target] = nodes[d.target] || { 
                    id: d.target, 
                    links: 0
                };
                nodes[d.source].links++;
                nodes[d.target].links++;
            });

            window.nodes = Object.values(nodes);
            window.links = data.map(d => ({
                source: d.source,
                target: d.target
            }));
        }

        function createSimulation() {
            simulation = d3.forceSimulation(window.nodes)
                .force('link', d3.forceLink(window.links)
                    .id(d => d.id)
                    .distance(d => Math.min(100, width * 0.1))
                )
                .force('charge', d3.forceManyBody()
                    .strength(d => -Math.min(1200, height * 2)))
                .force('center', d3.forceCenter(width/2, height/2))
                .force('collision', d3.forceCollide()
                    .radius(d => calculateNodeSize(d.links) + 5)
                );
        }

        function calculateNodeSize(linksCount) {
            const scale = d3.scaleLinear()
                .domain([1, d3.max(window.nodes, d => d.links)])
                .range([minNodeSize, maxNodeSize])
                .clamp(true);
            return scale(linksCount);
        }

        function renderElements() {
            const svg = d3.select('#main-svg');
            
            // 创建缩放行为
            zoom = d3.zoom()
                .scaleExtent([0.1, 8])
                .on('zoom', (event) => {
                    svg.selectAll('g.zoomable').attr('transform', event.transform);
                });

            svg.call(zoom);

            // 添加容器用于缩放
            const zoomableGroup = svg.append('g').attr('class', 'zoomable');

            // 绘制连线
            const link = zoomableGroup.append('g').attr('class', 'links')
                .selectAll('.link')
                .data(window.links)
                .join('line')
                .attr('class', 'link')
                .attr('marker-end', 'url(#arrow)');

            // 创建节点组
            const node = zoomableGroup.append('g').attr('class', 'nodes')
                .selectAll('.node')
                .data(window.nodes)
                .join('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded)
                );

            // 动态椭圆尺寸
            node.append('ellipse')
                .attr('rx', d => calculateNodeSize(d.links))
                .attr('ry', d => calculateNodeSize(d.links) * 0.6);

            // 节点文本 - 确保文字居中
            node.append('text')
                .text(d => d.id)
                .style('font-size', d => `${Math.min(14, calculateNodeSize(d.links)/2)}px`)
                .attr('dy', '0.35em');

            // 物理模拟更新
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // 调整初始视图以显示所有节点
            setTimeout(() => {
                const nodes = node.nodes();
                const xCoords = nodes.map(n => {
                    const transform = n.getAttribute('transform');
                    return transform ? +transform.split('(')[1].split(',')[0] : 0;
                });
                const yCoords = nodes.map(n => {
                    const transform = n.getAttribute('transform');
                    return transform ? +transform.split(',')[1].split(')')[0] : 0;
                });
                
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                const minY = Math.min(...yCoords);
                const maxY = Math.max(...yCoords);
                
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                const scale = 0.85 / Math.max(graphWidth / width, graphHeight / height);
                const translateX = width / 2 - scale * centerX;
                const translateY = height / 2 - scale * centerY;
                
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity
                        .translate(translateX, translateY)
                        .scale(scale));
            }, 1000);
        }

        function handleResize() {
            updateDimensions();
            d3.select('#main-svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height]);

            simulation
                .force('center', d3.forceCenter(width/2, height/2))
                .force('link').distance(d => Math.min(100, width * 0.1))
                .force('charge').strength(d => -Math.min(1200, height * 2))
                .alphaTarget(0.3)
                .restart();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.error);
            } else {
                document.exitFullscreen();
            }
        }

        function exportHighQualityPNG() {
            const svg = document.getElementById('main-svg');
            const svgData = new XMLSerializer().serializeToString(svg);
            
            // 创建临时SVG元素用于导出
            const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            tempSvg.innerHTML = svgData;
            
            // 获取实际内容尺寸
            const bbox = tempSvg.getBBox();
            const contentWidth = bbox.width + 40; // 添加边距
            const contentHeight = bbox.height + 40;
            
            // 设置临时SVG尺寸
            tempSvg.setAttribute('width', contentWidth);
            tempSvg.setAttribute('height', contentHeight);
            tempSvg.setAttribute('viewBox', `${bbox.x-20} ${bbox.y-20} ${contentWidth} ${contentHeight}`);
            
            // 创建Canvas
            const canvas = document.createElement('canvas');
            const scale = 2; // 提高导出质量
            canvas.width = contentWidth * scale;
            canvas.height = contentHeight * scale;
            
            const ctx = canvas.getContext('2d');
            ctx.scale(scale, scale);
            
            // 使用canvg渲染
            canvg(canvas, new XMLSerializer().serializeToString(tempSvg), {
                ignoreDimensions: true,
                ignoreClear: true,
                scaleWidth: contentWidth,
                scaleHeight: contentHeight,
                renderCallback: function() {
                    // 创建下载链接
                    const link = document.createElement('a');
                    link.download = 'knowledge-graph-export.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // 拖拽交互
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 全屏变化监听
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                handleResize();
            }
        });
    </script>
</body>
</html>