<!DOCTYPE html>
<html>
<head>
    <style>
        /* 全屏样式 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .control-btn {
            position: fixed;
            top: 10px;
            z-index: 1000;
            padding: 8px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial;
            font-size: 12px;
        }

        #fullscreen-btn {
            right: 10px;
        }

        #export-btn {
            right: 120px;
        }

        .node ellipse {
            stroke: #333;
            stroke-width: 1.5px;
        }

        .node text {
            font-weight: bold;
            font-family: Arial;
            pointer-events: none;
            text-anchor: middle;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .arrow {
            fill: #999;
            stroke-opacity: 0.6;
        }

        .target-node ellipse {
            fill: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="export-btn" class="control-btn">导出图片</button>
        <button id="fullscreen-btn" class="control-btn">全屏切换</button>
        <svg id="main-svg"></svg>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // 初始化变量
        let width, height;
        let simulation;
        let zoom;
        const minNodeSize = 20;
        const maxNodeSize = 60;

        // 全屏控制
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
        document.getElementById('export-btn').addEventListener('click', exportImage);

        // 初始化可视化
        initVisualization();

        async function initVisualization() {
            // 加载数据
            const data = await d3.csv('links.csv');
            
            // 首次渲染
            updateDimensions();
            setupSVG();
            processData(data);
            createSimulation();
            renderElements();

            // 窗口尺寸变化监听
            window.addEventListener('resize', handleResize);
        }

        function updateDimensions() {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        function setupSVG() {
            const svg = d3.select('#main-svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height]);

            // 添加箭头标记定义
            svg.append('defs').selectAll('marker')
                .data(['arrow'])
                .enter().append('marker')
                .attr('id', d => d)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 15)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('class', 'arrow')
                .attr('d', 'M0,-5L10,0L0,5');
        }

        function processData(data) {
            // 节点处理
            const nodes = {};
            data.forEach(d => {
                nodes[d.source] = nodes[d.source] || { id: d.source, links: 0, isTarget: false };
                nodes[d.target] = nodes[d.target] || { id: d.target, links: 0, isTarget: true };
                nodes[d.source].links++;
                nodes[d.target].links++;
            });

            window.nodes = Object.values(nodes);
            window.links = data.map(d => ({
                source: d.source,
                target: d.target
            }));
        }

        function createSimulation() {
            simulation = d3.forceSimulation(window.nodes)
                .force('link', d3.forceLink(window.links)
                    .id(d => d.id)
                    .distance(d => Math.min(100, width * 0.1)))
                .force('charge', d3.forceManyBody()
                    .strength(d => -Math.min(1200, height * 2)))
                .force('center', d3.forceCenter(width/2, height/2))
                .force('collision', d3.forceCollide()
                    .radius(d => calculateNodeSize(d.links) + 5));
        }

        function calculateNodeSize(linksCount) {
            const scale = d3.scaleLinear()
                .domain([1, d3.max(window.nodes, d => d.links)])
                .range([minNodeSize, maxNodeSize])
                .clamp(true);
            return scale(linksCount);
        }

        function renderElements() {
            const svg = d3.select('#main-svg');
            
            // 创建缩放行为
            zoom = d3.zoom()
                .scaleExtent([0.1, 8])
                .on('zoom', (event) => {
                    svg.selectAll('.nodes-container').attr('transform', event.transform);
                    svg.selectAll('.links-container').attr('transform', event.transform);
                });

            svg.call(zoom);

            // 添加容器用于缩放
            const linksContainer = svg.append('g').attr('class', 'links-container');
            const nodesContainer = svg.append('g').attr('class', 'nodes-container');

            // 绘制连线
            const link = linksContainer.selectAll('.link')
                .data(window.links)
                .join('line')
                .attr('class', 'link')
                .attr('stroke-width', 1.2)
                .attr('marker-end', 'url(#arrow)');

            // 创建节点组
            const node = nodesContainer.selectAll('.node')
                .data(window.nodes)
                .join('g')
                .attr('class', d => `node ${d.isTarget ? 'target-node' : ''}`)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded)
                );

            // 动态椭圆尺寸
            node.append('ellipse')
                .attr('rx', d => calculateNodeSize(d.links))
                .attr('ry', d => calculateNodeSize(d.links) * 0.6)
                .attr('fill', '#4CAF50')
                .attr('stroke', '#2E7D32');

            // 节点文本
            node.append('text')
                .text(d => d.id)
                .attr('dy', '0.3em')
                .style('font-size', d => `${Math.min(14, calculateNodeSize(d.links)/2)}px`);

            // 物理模拟更新
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // 调整初始视图以显示所有节点
            setTimeout(() => {
                const bounds = nodesContainer.node().getBBox();
                const centerX = bounds.x + bounds.width / 2;
                const centerY = bounds.y + bounds.height / 2;
                const scale = Math.min(0.8 * width / bounds.width, 0.8 * height / bounds.height, 1);
                
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity
                        .translate(width / 2 - centerX * scale, height / 2 - centerY * scale)
                        .scale(scale));
            }, 1000);
        }

        function handleResize() {
            updateDimensions();
            d3.select('#main-svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height]);

            simulation
                .force('center', d3.forceCenter(width/2, height/2))
                .force('link').distance(d => Math.min(100, width * 0.1))
                .force('charge').strength(d => -Math.min(1200, height * 2))
                .alphaTarget(0.3)
                .restart();
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.error);
            } else {
                document.exitFullscreen();
            }
        }

        function exportImage() {
            const svg = document.getElementById('main-svg');
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            
            const canvas = document.createElement('canvas');
            canvas.width = svg.width.baseVal.value;
            canvas.height = svg.height.baseVal.value;
            
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                const dataURL = canvas.toDataURL('image/png');
                
                const link = document.createElement('a');
                link.download = 'network-graph.png';
                link.href = dataURL;
                link.click();
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgStr)));
        }

        // 拖拽交互
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // 全屏变化监听
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                handleResize();
            }
        });
    </script>
</body>
</html>